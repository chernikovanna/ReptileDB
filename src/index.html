<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="./d3-simple-slider.js"></script>

<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="./virtualscroller.js"></script>

<div class="row align-items-center">
   <div class="col-sm-2"><p id="value-range"></p></div>
   <div class="col-sm"><div id="slider-range"></div></div>
 </div>
<!-- Create an element where the map will take place -->
<!-- <svg id="my_dataviz" viewBox="0 0 800 1000"  height="800" width="1000"></svg>-->
<svg id="my_dataviz" height="800" width="1000"></svg>
<div id="halfpage"></div>


<div id="arrayStrContainerCountry"></div>

<div id="arrayStrContainer"></div>

<svg id="tb" width="400" height = "800"></svg>
<style>
        div#halfpage{
        height: 900px;
        width: 800px;
        border:2px solid #000;
        overflow-y: auto;
        }
        svg#sky {
          height: 1000px;
          width: 1100px;
          border:1px dotted #ccc;
          background-color: #ccc;
       }
    </style>
<script>
var years = [];
var pops = [];

var svg = d3.select("#my_dataviz"),
  width = +svg.attr("width"),
  height = +svg.attr("height");

var s;

// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
  .scale(150)
  .center([0,0])
  .translate([width / 2, height / 2]);

// Data and color scale
var data = d3.map();
var cl = []
var sp = {}


d3.json("species.json", function(d){
  sp = d;
});
// Load external data and boot
d3.queue()
  .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
  .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv",
  function(d) {
    data.set(d.code, +d.pop)})
  .await(ready);


async function fetchAllData (j) {
  // await response of a fetch call
  const response = await fetch(j);
  // once the promise is resolved convert the response to an object
  const data = await response.json();
  // your data has been converted to an object now)
  return data;
}

function ready(error, topo) {
  var cl;
  d3.json("species.json", function(dd){
    sp = dd;
    console.log(dd)
    d3.json("countries.json", function(d){
      // data stuff
      cl = d;
      for (var i = 0; i < topo.features.length; i++){
        topo.features[i].datum = cl[topo.features[i].properties.name]
        if (topo.features[i].datum != undefined){
          for (var j = 0; j < topo.features[i].datum.length; j++){
            var species_name = topo.features[i].datum[j]
            topo.features[i].datum[j] = {}
            topo.features[i].datum[j].name = species_name
            topo.features[i].datum[j].attr = dd[species_name];
            years.push(dd[species_name].year)
          }
        }
      }



      //slider bar
      console.log(years)
      var sliderRange = d3
    .sliderBottom()
    .min(d3.min(years))
    .max(d3.max(years))
    .width(300)
    .tickFormat(d3.format('4.0f'))
    .ticks(10)
    .default([0.015, 0.02])
    .fill('#2196f3')
    .on('onchange', val => {
      d3.select('p#value-range').text(val.map(d3.format('4.0f')).join('-'));
      console.log(val)
      update(topo, yearFilter,val)
    });

  var gRange = d3
    .select('div#slider-range')
    .append('svg')
    .attr('width', 500)
    .attr('height', 100)
    .append('g')
    .attr('transform', 'translate(30,30)');

  gRange.call(sliderRange);

  d3.select('p#value-range').text(
    sliderRange
      .value()
      .map(d3.format('4.0f'))
      .join('-')
  );


      update(topo, null);

    });
  });
};

function yearFilter(input_data, value){
  ret = []
  if (input_data == undefined){
    return input_data
  }else {
    for (var i = 0; i < input_data.length; i++){
      if (input_data[i].attr.year <= value[1] && input_data[i].attr.year >= value[0]){
        ret.push(input_data[i])
      }
    }
    return ret;
  }
}

function update(topo, func, value){

  let topo2 = JSON.parse(JSON.stringify(topo));


  var sizes = [];
  //update data
  if (func != null){
    for (var i = 0; i < topo.features.length; i++){

      topo2.features[i].datum = func(topo.features[i].datum, value)
      if (topo2.features[i].datum != undefined){
        sizes.push(topo2.features[i].datum.length)
      } else{
        sizes.push(0)
      }
    }
  }

    var colorScale = d3.scaleSequential().domain([d3.min(sizes),d3.max(sizes)])
    .interpolator(d3.interpolateRgb("purple", "orange"));

  //draw map
  svg.append("g")
  .selectAll("path")
  .data(topo2.features)
  .enter()
  .append("path")
  .attr("d", d3.geoPath().projection(projection))
  .attr("fill", function (d) {

    l = 0
    if (d.datum != undefined){
        l = d.datum.length
    }

    return colorScale(l);
  })
  .on('click',function(d){
    s = d3.select("#tb")
    t = ""
    a = []
    if (d.datum != undefined){
      for(var i = 0; i < d.datum.length; i++){
        t = d.datum[i].name
        a.push(t);
        s.append("text").attr("x", 20).attr("y", (i + 1)*20);
        s.text(t);
      }
    }
    node = d3.selectAll('g node');
    updateList(d.datum)
    d3.select('#arrayStrContainer').text(JSON.stringify(a));
    d3.select('#arrayStrContainerCountry').text(JSON.stringify(d.properties.name))
  });
}

function updateList(list){
  //species Bar
  var container = d3.select("#halfpage")

    var svgContainer = container.append('svg')
        //.attr('height', 100)
        //.attr('width', 100)
        .attr('id', 'sky');

    svgContainer.selectAll("g")//.append("rects1")
                .data(list)
                .enter()
                .append("rect")
                .attr("width", 400)
                .attr("height", 50)
                .attr("x", 12)
                .attr("y", function(d, i){
                    return 100 * i;
                })
                .style("fill", "white")

                svgContainer.selectAll("text")
                .data(list)
                .enter()
                .append("text")
                    .attr("x", function(d) { return 100 })
                    .attr("y", function(d, i){
                        return 100 * i + 20;
                    })
                    .attr("dy", ".35em")
                    .text(function(d) { console.log(d);return d.name; })
                    .style('fill', 'Black')
                    .style('font-size',"25");

}
var promises = [];

//var files = []
  //for (var i = 0; i < topo.features.length; i++){
    //files.push("https://api.reptile-database.org/species?genus=" + g + "&species=" + s)
    //files.push("https://api.reptile-database.org/search?distribution=" + topo.features[i].properties.name);
  //}
  //files.forEach(function(url) {
  //    promises.push( fetchAllData(url))
  //});

  //Promise.all(promises).then(function(values) {
      //for (var i = 0; i < values.length; i++){
      //  topo.features[i].size = values[i].length
      //  topo.features[i].datum = values[i]
      //}
      // Draw the map


//}



</script>
