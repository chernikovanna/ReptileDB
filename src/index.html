<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="./d3-simple-slider.js"></script>

<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="./virtualscroller.js"></script>

<div class="row align-items-center">
   <div class="col-sm-2"><p id="value-range"></p></div>
   <div class="col-sm"><div id="slider-range"></div></div>
   <select id="selectButton"></select>
 </div>


<!-- Create an element where the map will take place -->
<!-- <svg id="my_dataviz" viewBox="0 0 800 1000"  height="800" width="1000"></svg>-->
  <div id="container">
  <div id="worldmap">
  <svg id="my_dataviz" ></svg>
  </div>
  <div id="halfpage">
  <!--<svg id="sky"> </svg>-->
  </div>
  <div id="clear"></div>

    </div>


<div id="arrayStrContainerCountry"></div>

<div id="arrayStrContainer"></div>

<svg id="tb" width="400" height = "800"></svg>
<style>
/*.svg-content-responsive {
  display: inline-block;
  position: absolute;
  top: 10px;
  left: 0;
}*/

.col-sm{
  display:inline-block;
  width: 75%;
}
select#selectButton{
  display:inline-block;
  width: 20%;
}
#clear {
    clear: both;
}
div#container {
  margin: auto;
}
        div#worldmap{
          float:left;
          display: inline-block;
          width: 75%

        }

        div#halfpage{
          float:left;
          display:inline-block;
        width: 24%;
        border:2px solid #000;
        overflow-y: auto;
        height: 500px;
        }
        /*svg#my_dataviz{
          display: inline-block;
          position: relative;
          width: 100%;
          height: 1000px
          padding-bottom: 2%;
          vertical-align: top;
          overflow: hidden;
        }*/

        svg#sky {
          /*height: 1000px;*/
          width: 100%;
          border:1px dotted #ccc;
          background-color: #ccc;
       }
    </style>
<script>
var years = [];
var pops = [];

var svg = d3.select("#my_dataviz")
 .attr("preserveAspectRatio", "xMinYMin meet")
 .attr("viewBox", "0 0 1000 800")
 .classed("svg-content-responsive", true),
  width = +svg.attr("width"),
  height = +svg.attr("height");

var s;

// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
  .scale(150)
  .center([0,0])
  .translate([1000 / 2, 800 / 2]);

// Data and color scale
var data = d3.map();
var cl = []
var sp = {}


d3.json("species.json", function(d){
  sp = d;
});
// Load external data and boot
d3.queue()
  .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
  .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world_population.csv",
  function(d) {
    data.set(d.code, +d.pop)})
  .await(ready);


async function fetchAllData (j) {
  // await response of a fetch call
  const response = await fetch(j);
  // once the promise is resolved convert the response to an object
  const data = await response.json();
  // your data has been converted to an object now)
  return data;
}

function ready(error, topo) {
  var cl;
  d3.json("species.json", function(dd){
    sp = dd;




    d3.json("countries.json", function(d){
      // data stuff
      cl = d;
      for (var i = 0; i < topo.features.length; i++){
        topo.features[i].datum = cl[topo.features[i].properties.name]
        if (topo.features[i].datum != undefined){
          for (var j = 0; j < topo.features[i].datum.length; j++){
            var species_name = topo.features[i].datum[j]
            topo.features[i].datum[j] = {}
            topo.features[i].datum[j].name = species_name
            topo.features[i].datum[j].attr = dd[species_name];
            years.push(dd[species_name].year)
          }
        }
      }

      //filter by taxa
      myList = [];
      for (var key in dd){
        myList.push.apply(myList, dd[key].taxa.split(/[,;]+/))
      }
      const unique = [...new Set(myList)];
      d3.select("#selectButton")
        .selectAll('myOptions')
       	.data(unique)
        .enter()
      	.append('option')
        .text(function (d) { return d; }) // text showed in the menu
        .attr("value", function (d) { return d; })
        d3.select("#selectButton").on("change", function(d) {
          // recover the option that has been chosen
          var selectedOption = d3.select(this).property("value")
          // run the updateChart function with this selected option
          update(topo, taxFilter, selectedOption)
      }) // correspond


      //slider bar
      var sliderRange = d3
    .sliderBottom()
    .min(d3.min(years))
    .max(d3.max(years))
    .width(300)
    .tickFormat(d3.format('4.0f'))
    .ticks(10)
    .default([d3.min(years), d3.max(years)])
    .fill('#2196f3')
    .on('onchange', val => {
      d3.select('p#value-range').text(val.map(d3.format('4.0f')).join('-'));
      console.log(val)
      update(topo, yearFilter,val)
    });

  var gRange = d3
    .select('div#slider-range')
    .append('svg')
    .attr('width', 500)
    .attr('height', 100)
    .append('g')
    .attr('transform', 'translate(30,30)');

  gRange.call(sliderRange);

  d3.select('p#value-range').text(
    sliderRange
      .value()
      .map(d3.format('4.0f'))
      .join('-')
  );


      update(topo, null, null);

    });
  });
};

function yearFilter(input_data, value){
  ret = []
  if (input_data == undefined){
    return input_data
  }else {
    for (var i = 0; i < input_data.length; i++){
      if (input_data[i].attr.year <= value[1] && input_data[i].attr.year >= value[0]){
        ret.push(input_data[i])
      }
    }
    return ret;
  }
}

function taxFilter(input_data, value){
  ret = []

  if (input_data == undefined){
    return input_data
  }else {
    for (var i = 0; i < input_data.length; i++){
      if (input_data[i].attr.taxa.includes(value)){
        ret.push(input_data[i])
      }
    }
  return ret;
}
}
function update(topo, func, value){

  let topo2 = JSON.parse(JSON.stringify(topo));


  var sizes = [];
  //update data
  if (func != null){
    for (var i = 0; i < topo.features.length; i++){

      topo2.features[i].datum = func(topo.features[i].datum, value)
      if (topo2.features[i].datum != undefined){
        sizes.push(topo2.features[i].datum.length)
      } else{
        sizes.push(0)
      }
    }
  } else{
    for (var i = 0; i < topo.features.length; i++){
      if (topo2.features[i].datum != undefined){
        sizes.push(topo2.features[i].datum.length)
      } else{
        sizes.push(0)
      }
    }

  }

    var colorScale = d3.scaleSequential().domain([d3.min(sizes),d3.max(sizes)])
    .interpolator(d3.interpolateRgb("purple", "orange"));

  //draw map
  svg.append("g")
  .selectAll("path")
  .data(topo2.features)
  .enter()
  .append("path")
  .attr("d", d3.geoPath().projection(projection))
  .attr("fill", function (d) {
    l = "#808080"
    if (d.datum != undefined){
        l = colorScale(d.datum.length);
    }
    return l;
  })
  .on('click',function(d){
    s = d3.select("#tb")
    t = ""
    a = []
    if (d.datum != undefined){
      for(var i = 0; i < d.datum.length; i++){
        t = d.datum[i].name
        a.push(t);
        s.append("text").attr("x", 20).attr("y", (i + 1)*20);
        s.text(t);
      }
    }
    //node = d3.selectAll('g node');
    updateList(d.datum)
    //d3.select('#arrayStrContainer').text(JSON.stringify(a));
    //d3.select('#arrayStrContainerCountry').text(JSON.stringify(d.properties.name))
  });
}

function updateList(list){
  //species Bar
  //var container = d3.select("#halfpage")

  d3.select("#sky").remove();
    var svgContainer = d3.select("#halfpage").append('svg')
        .attr('height', list.length * 60)
        .attr('width', 300)
        .attr('id', 'sky');
        console.log(svgContainer.attr("width"))

    svgContainer.selectAll("g")//.append("rects1")
                .data(list)
                .enter()
                .append("rect")
                .attr("width", 250)
                .attr("height", 30)
                .attr("x", 12)
                .attr("y", function(d, i){
                    return 50 * i;
                })
                .style("fill", "white")

                svgContainer.selectAll("text")
                .data(list)
                .enter()
                .append("text")
                    .attr("x", function(d) { return 15 })
                    .attr("y", function(d, i){
                        return 50 * i + 20;
                    })
                    .attr("dy", ".35em")
                    .text(function(d) { console.log(d);return d.name; })
                    .style('fill', 'Black')
                    .style('font-size',"20");

}
var promises = [];

//var files = []
  //for (var i = 0; i < topo.features.length; i++){
    //files.push("https://api.reptile-database.org/species?genus=" + g + "&species=" + s)
    //files.push("https://api.reptile-database.org/search?distribution=" + topo.features[i].properties.name);
  //}
  //files.forEach(function(url) {
  //    promises.push( fetchAllData(url))
  //});

  //Promise.all(promises).then(function(values) {
      //for (var i = 0; i < values.length; i++){
      //  topo.features[i].size = values[i].length
      //  topo.features[i].datum = values[i]
      //}
      // Draw the map


//}



</script>
